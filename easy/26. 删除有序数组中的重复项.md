# 26. 删除有序数组中的重复项

给你一个 **升序排列** 的数组 `nums` ，请你 原地 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。

由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 `k` 个元素，那么 `nums` 的前 `k` 个元素应该保存最终结果。

将最终结果插入 `nums` 的前 `k` 个位置后返回 `k` 。

不要使用额外的空间，你必须在 原地 **修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

**示例 1：**

```
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

**提示：**

- 1 <= nums.length <= 3 * 104
- -104 <= nums[i] <= 104
- nums 已按 升序 排列

**思路一：**
单指针
```javascript
var removeDuplicates = function (nums) {
  for (let i = 0; i < nums.length - 1; i++) {
    if (nums[i] === nums[i + 1]) {
      nums.splice(i + 1, 1);
      i--;
    }
  }
  return nums.length;
};
```
**思路二：**
双指针
```javascript
var removeDuplicates = function(nums) {
  let i = 0;  // 慢指针，指向当前不重复元素的最后一个位置
  for(let j = 1; j < nums.length; j++){  // 快指针，遍历数组
      if(nums[j] !== nums[i]){  // 发现新的不重复元素
          nums[i+1] = nums[j];  // 将新元素放到慢指针的下一个位置
          i++  // 慢指针向前移动
      }
  }
  return i + 1  // 返回新数组的长度
};
```

## 思路二详解：双指针解法

### 核心思想
使用**双指针技术**，通过一个慢指针和一个快指针来原地修改数组：
- **慢指针 `i`**：指向当前已处理的不重复元素的最后一个位置
- **快指针 `j`**：遍历整个数组，寻找新的不重复元素

### 执行过程
以 `nums = [0,0,1,1,1,2,2,3,3,4]` 为例：

1. **初始状态**：`i = 0, j = 1`
   - `nums[0] = 0` 是第一个元素，直接保留
   - `nums[1] = 0` 与 `nums[0]` 相同，跳过

2. **发现新元素**：`j = 2, nums[2] = 1`
   - `nums[2] ≠ nums[0]`，将 `nums[2]` 放到 `nums[1]` 位置
   - `i++` 变为 1
   - 数组变为 `[0,1,1,1,1,2,2,3,3,4]`

3. **继续遍历**：`j = 3,4,5`
   - `nums[3] = 1, nums[4] = 1` 都与 `nums[1] = 1` 相同，跳过
   - `nums[5] = 2` 与 `nums[1] = 1` 不同，放到 `nums[2]` 位置
   - `i++` 变为 2
   - 数组变为 `[0,1,2,1,1,2,2,3,3,4]`

4. **最终结果**：遍历完成后，前 `i+1` 个位置包含所有不重复元素

### 优势
1. **时间复杂度**：O(n)，只需要遍历一次数组
2. **空间复杂度**：O(1)，原地修改，不使用额外空间
3. **效率高**：避免了 `splice` 操作，减少了数组元素的移动

### 与思路一的对比
思路一使用 `splice` 删除重复元素，每次删除都会导致数组重新排列，时间复杂度为 O(n²)。而思路二通过双指针直接覆盖，避免了数组重排，效率更高。