# 350. 两个数组的交集II

给你两个整数数组 `nums1` 和 `nums2` ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

**示例 1：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
```

**示例 2：**

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```

**提示：**

- 1 <= nums1.length, nums2.length <= 1000
- 0 <= nums1[i], nums2[i] <= 1000

**思路一：排序+双指针**

**核心思想：**
通过排序将两个数组变成有序数组，然后使用双指针技术来找到交集。

**算法步骤：**
1. 对两个数组分别进行排序
2. 使用两个指针 `l1` 和 `l2` 分别指向两个数组的起始位置
3. 比较指针指向的元素：
   - 如果相等，说明找到了交集元素，加入结果数组，两个指针都向前移动
   - 如果 `nums1[l1] > nums2[l2]`，移动 `l2` 指针
   - 如果 `nums1[l1] < nums2[l2]`，移动 `l1` 指针
4. 重复步骤3直到其中一个指针到达数组末尾

**时间复杂度：** O(nlogn + mlogm)，其中 n 和 m 是两个数组的长度
**空间复杂度：** O(1)，不考虑排序的空间开销

**优点：** 空间复杂度低
**缺点：** 需要修改原数组（排序）

```javascript
var intersect = function (nums1, nums2) {
  nums1 = nums1.sort((a, b) => a - b);
  nums2 = nums2.sort((a, b) => a - b);
  let l1 = 0;
  let l2 = 0;
  const nums1Len = nums1.length;
  const nums2Len = nums2.length;
  const ret = [];
  while (l1 < nums1Len && l2 < nums2Len) {
    if (nums1[l1] === nums2[l2]) {
      ret.push(nums1[l1]);
      l1++;
      l2++;
    }
    if (nums1[l1] > nums2[l2]) l2++;
    if (nums1[l1] < nums2[l2]) l1++;
  }
  return ret;
};
```

**思路二：哈希表**

**核心思想：**
使用哈希表记录第一个数组中每个元素出现的次数，然后遍历第二个数组，如果元素在哈希表中存在且计数大于0，则加入结果并减少计数。

**算法步骤：**
1. 创建一个哈希表 `map`
2. 遍历第一个数组 `nums1`，统计每个元素出现的次数
3. 遍历第二个数组 `nums2`：
   - 如果元素在哈希表中存在且计数大于0
   - 将该元素加入结果数组
   - 减少哈希表中该元素的计数
4. 返回结果数组

**时间复杂度：** O(n + m)
**空间复杂度：** O(min(n, m))

**优点：** 时间复杂度最优，不需要排序
**缺点：** 需要额外的哈希表空间

```javascript
var intersect = function (nums1, nums2) {
  let map = {};
  let ret = [];
  nums1.forEach((item)=>{
      map[item] = (map[item]||0) + 1;
  })
  nums2.forEach(item=>{
      if(map[item]!==undefined&&map[item]!==0){
          map[item]--;
          ret.push(item)
      }
  })
  return ret
};
```

## 两种解法的比较

| 方面           | 排序+双指针      | 哈希表       |
| -------------- | ---------------- | ------------ |
| 时间复杂度     | O(nlogn + mlogm) | O(n + m)     |
| 空间复杂度     | O(1)             | O(min(n, m)) |
| 是否修改原数组 | 是               | 否           |
| 实现复杂度     | 中等             | 简单         |

**选择建议：**
- 如果对空间要求严格，选择排序+双指针
- 如果对时间要求严格，选择哈希表
- 如果数组已经有序，排序+双指针会更高效
- 如果数组元素范围很大，哈希表可能更合适

两种解法都能正确处理重复元素的情况，确保返回的交集中每个元素出现的次数等于两个数组中该元素出现次数的最小值。