# 70. 爬楼梯

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

## 思路理解

### 方法一：动态规划（推荐）

**核心思想：** 要到达第 n 阶，你只能从第 n-1 阶走 1 步，或者从第 n-2 阶走 2 步。

**可视化理解：**

```
n=1: [1]                    → 1种方法
n=2: [1,1] 或 [2]          → 2种方法  
n=3: [1,1,1] 或 [1,2] 或 [2,1] → 3种方法
n=4: [1,1,1,1] 或 [1,1,2] 或 [1,2,1] 或 [2,1,1] 或 [2,2] → 5种方法
```

**递推关系：**
- `dp[n] = dp[n-1] + dp[n-2]`
- 因为到达第 n 阶的方法数 = 从第 n-1 阶走 1 步的方法数 + 从第 n-2 阶走 2 步的方法数

**具体例子：**
```
dp[1] = 1  (只有一种方法：走1步)
dp[2] = 2  (两种方法：1+1 或 2)
dp[3] = dp[2] + dp[1] = 2 + 1 = 3
dp[4] = dp[3] + dp[2] = 3 + 2 = 5
dp[5] = dp[4] + dp[3] = 5 + 3 = 8
```

### 方法二：递归理解

**递归思路：**
- 如果 n ≤ 2，直接返回 n
- 否则，f(n) = f(n-1) + f(n-2)

**递归树示例（n=4）：**
```
f(4)
├── f(3) (走1步到第4阶)
│   ├── f(2) (走1步到第3阶)
│   │   ├── f(1) (走1步到第2阶) = 1
│   │   └── f(0) (走2步到第2阶) = 1
│   └── f(1) (走2步到第3阶) = 1
└── f(2) (走2步到第4阶) = 2
```

## 代码实现

```javascript
var climbStairs = function (n) {
  const dp = {};
  dp[1] = 1;
  dp[2] = 2;
  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n]
};
```

**优化版本（空间优化）：**
```javascript
var climbStairs = function(n) {
  if (n <= 2) return n;
  
  let prev1 = 1;  // dp[i-2]
  let prev2 = 2;  // dp[i-1]
  
  for (let i = 3; i <= n; i++) {
    const current = prev1 + prev2;
    prev1 = prev2;
    prev2 = current;
  }
  
  return prev2;
};
```

## 总结

这个问题本质上是**斐波那契数列**的变种：
- 每次只能走 1 步或 2 步
- 当前状态只依赖于前两个状态
- 时间复杂度：O(n)，空间复杂度：O(1)（优化后）

