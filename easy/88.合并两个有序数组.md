# 88.合并两个有序数组

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 合并 `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 `nums1` `中。为了应对这种情况，nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

**示例 1：**

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

**示例 2：**

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。
```

**示例 3：**

```
输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
```

**提示：**

- nums1.length == m + n
- nums2.length == n
- 0 <= m, n <= 200
- 1 <= m + n <= 200
- -109 <= nums1[i], nums2[j] <= 109

**进阶：** 你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？

**思路：**
```javascript
var merge = function (nums1, m, nums2, n) {
  // 1. 初始化指针位置
  let len = m + n - 1;  // 结果数组的最后一个位置
  m--, n--;             // 分别指向两个数组的最后一个有效元素
  
  // 2. 从后往前比较和合并
  while (m >= 0 && n >= 0) {
    if (nums1[m] > nums2[n]) {
      nums1[len] = nums1[m--];  // 选择较大的数
    } else {
      nums1[len] = nums2[n--];  // 选择较大的数
    }
    len--;  // 向前移动结果指针
  }
  
  // 3. 处理剩余元素
  if (m === -1) {
    // nums1 已经用完，将 nums2 剩余元素复制到前面
    return nums1.splice(0, len + 1, ...nums2.slice(0, n + 1));
  }
  if (n === -1) {
    // nums2 已经用完，nums1 剩余元素已经在正确位置
    return nums1;
  }
};
```

## 详细解析

### 1. 问题特点分析

- `nums1` 有足够的空间（长度为 `m + n`）
- 两个数组都是**非递减顺序**（升序）
- 需要将结果直接存储在 `nums1` 中
- 不能使用额外的数组空间

### 2. 核心思路：从后往前合并

**为什么从后往前？**
- 如果从前往后合并，会覆盖 `nums1` 中还未使用的元素
- 从后往前可以避免覆盖问题，因为 `nums1` 后半部分都是 0

### 4. 执行过程示例

以示例1为例：`nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3`

```
初始状态：
nums1: [1, 2, 3, 0, 0, 0]
nums2: [2, 5, 6]
指针位置：len=5, m=2, n=2

第1步：比较 nums1[2]=3 和 nums2[2]=6
3 < 6，所以 nums1[5] = 6
nums1: [1, 2, 3, 0, 0, 6]
指针：len=4, m=2, n=1

第2步：比较 nums1[2]=3 和 nums2[1]=5
3 < 5，所以 nums1[4] = 5
nums1: [1, 2, 3, 0, 5, 6]
指针：len=3, m=2, n=0

第3步：比较 nums1[2]=3 和 nums2[0]=2
3 > 2，所以 nums1[3] = 3
nums1: [1, 2, 3, 3, 5, 6]
指针：len=2, m=1, n=0

第4步：比较 nums1[1]=2 和 nums2[0]=2
2 = 2，所以 nums1[2] = 2
nums1: [1, 2, 2, 3, 5, 6]
指针：len=1, m=1, n=-1

nums2 已用完，nums1 剩余元素已在正确位置
最终结果：[1, 2, 2, 3, 5, 6]
```

### 5. 时间复杂度分析

- **时间复杂度：O(m + n)** - 只需要遍历两个数组各一次
- **空间复杂度：O(1)** - 只使用了常数个额外变量

### 6. 优化建议

当前代码中的 `splice` 操作可以优化为更简单的循环：

```javascript
// 优化后的处理剩余元素部分
if (n >= 0) {
  // 将 nums2 剩余元素复制到 nums1 前面
  for (let i = 0; i <= n; i++) {
    nums1[i] = nums2[i];
  }
}
```

### 7. 完整优化版本

```javascript
var merge = function (nums1, m, nums2, n) {
  let len = m + n - 1;
  m--, n--;
  
  while (m >= 0 && n >= 0) {
    if (nums1[m] > nums2[n]) {
      nums1[len] = nums1[m--];
    } else {
      nums1[len] = nums2[n--];
    }
    len--;
  }
  
  // 如果 nums2 还有剩余元素，复制到 nums1 前面
  while (n >= 0) {
    nums1[len] = nums2[n--];
    len--;
  }
};
```

这种从后往前合并的方法充分利用了 `nums1` 后半部分的空间，避免了元素覆盖问题，是一个非常优雅的解决方案。